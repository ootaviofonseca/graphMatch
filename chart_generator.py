from langchain_openai import ChatOpenAI
from langchain.agents import create_agent
from langchain.tools import tool
from langchain_core.output_parsers import StrOutputParser

import os
from dotenv import load_dotenv

import sys
@tool
def execute_code(code: str) -> str:
    """
    Execute the code generated by the previous agent
    """

    import subprocess

    # Creates a command that runs Python and reads the code from the string
    process = subprocess.Popen(
        [sys.executable, "-c", code],  # The '-c'option allows passing code as a string
        stdout=subprocess.PIPE,   # Captures the output
        stderr=subprocess.PIPE,   # Captures errors
        text=True
    )

    # Espera o processo terminar e captura saída e erros
    stdout, stderr = process.communicate()
    if process.returncode == 0:
        return f"Code executed successfully, output: {stdout}"
    else:
        return f"The code produced the following errors: {stderr}"

class ChartGeneratorAgent:

    def __init__(self):
        # Load o .env
        load_dotenv()
        # Retrieves the key
        api_key = os.getenv("OPENAI_API_KEY")

        # If not found, returns an error
        if not api_key:
            raise ValueError("OPENAI_API_KEY not found in .env file")

        # Defining the model and creating the agent tat create the code
        self.model =  ChatOpenAI(model="gpt-3.5-turbo",  openai_api_key=api_key)
        self.code_generator = create_agent(
            model=self.model,
        )

        #Agent that test and correct the code
        self.code_tester = create_agent(
            model=self.model,
            tools=[execute_code],
            system_prompt= ("You receive the code and execute it using the tool. "
                "If errors occur, correct them and run it again. "
                "If the error persists more than three times, stop and return a message stating "
                "that the code presented errors and print the errors."
            )
        )

        # Parser to standardize the output
        self.parser = StrOutputParser()

    def generate_code(self, chart_type: str, question: str, summary: str) -> str:
        
        prompt = (
            f"You are a coding assistant specialized in data visualization using Altair. "
            f"Generate only the Python code that creates an Altair chart of type {chart_type} "
            f"that answers the user’s question: {question}. "
            f"You are given a brief description of the dataframe: {summary}. "
            f"The generated code must follow this format (values, columns, and chart type can vary, but keep the structure):\n\n"
            f"import altair as alt\n"
            f"import pandas as pd\n"
            f"import vl_convert as vlc\n"
            f"import os\n"
            f"import uuid\n\n"
            f"path = 'visEval_dataset/databases/activity_1/Student.csv'\n"
            f"data = pd.read_csv(path)\n\n"
            f"# Create a chart\n"
            f"chart = alt.Chart(data).mark_<chart_type>().encode(\n"
            f"    x='<x_column>:<type>',\n"
            f"    y='<y_column>:<type>',\n"
            f").properties(\n"
            f"    title='<chart_title>'\n"
            f")\n\n"
            f"# Convert the chart to PNG\n"
            f"png_bytes = vlc.vegalite_to_png(chart.to_dict())\n\n"
            f"# Ensure the results folder exists and save the PNG with a unique name\n"
            f"os.makedirs('results', exist_ok=True)\n"
            f"filename = f'results/grafico_{{uuid.uuid4().hex}}.png'\n"
            f"with open(filename, 'wb') as f:\n"
            f"    f.write(png_bytes)\n\n"
            f"The agent should NOT read any dataframe from the environment; "
            f"just use the fixed path in the code. "
            f"The structure of the chart may change depending on the chart type, but the path, imports, chart object, PNG conversion, and saving with a unique filename must always remain."
        )

        result = self.code_generator.invoke({
            "messages": [{"role": "user", "content": prompt}]
        })

        #Extract only the code part from the agent's response
        response = self.parser.invoke(result["messages"][-1])
    
        print (response)
        return response
    
        
    def generate_and_test_code(self, chart_type: str, question: str, summary: str) -> str:
            """
            Full workflow: generate code → execute → correct if there is an error.
            """
            
            code = self.generate_code(chart_type, question, summary)
            
            test_result = self.code_tester.invoke({
                "messages": [{"role": "user", "content": code}]
            })
            
            return self.parser.invoke(test_result["messages"][-1])

